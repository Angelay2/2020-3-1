#include <stdio.h>
#include <Windows.h>
#pragma warning(disable:4996)

// C语言文件操作(内容 属性)
// 文件是在磁盘或硬盘里存储, 程序运行时,先把程序从硬盘里读入内存
// 程序的运行流程：先把数据从硬盘读到内存里面，cpu再从内存里面调数据，
// cpu里面有一个寄存器来缓存数据，用来缓解cpu和内存的速度差。
// 内存里面也有一个缓存，用来缓解内存和硬盘的一个速度差。

// 硬盘(存储容量手机64G,128G/永久性存储介质)和内存(4G/ 易失性存储性介质,耗电量大)
// 文件(创建时间 创建人 文件大小 文件类型 文件名 => 都是属性不是内容, 也占空间)
// 文件 = 文件内容+文件属性 属性也是数据 也要占据内存
// 机械硬盘是计算机中唯一一个机械设备,硬盘是个机械设备 
// 硬盘里的盘片(手掌大小,两面都是光面的)在转会发出声音 转速越快 电脑硬盘越贵 
// 文件名 = 文件路径 + 文件名主干 + 文件后缀 
// 显示器是模拟器 终端是哪个黑框框 
// 虽然有CDEF盘 但其实只有一个盘 cdef是分区, c:\code\test.txt c:是盘符 \路径分隔符 \\之间的是文件夹
// 文本文件:(记事本)写的是什么打开也是什么 二进制变为ASCII码形式存 ASCII码本质是整数
// 二进制文件: (音频 视频 图片 库)打开看不懂 图片是给图片解释器看的 
// 数据在内存中一二进制的形式存储, 如果不加转换的输出到外存(硬盘 除了内存外) 就是二进制文件
// 整数10000 如果以ASCII码形式输出到磁盘,磁盘占用5个字节 二进制形式占4个字节(化为其对应的二进制序列)
// 能看到的数字 字 都是字符

// 把一个文件打开之后, 通过文件指针向该文件里写入一个在内存中的4字节数据
// 在内存上是什么 在硬盘上就是什么 都是4字节 
int main1(){
	int a = 10000;// 
	// wb表示以二进制形式写入 w表示以文本形式写入	
	//FILE* fp = fopen("my.bin", "wb");
	FILE* fp = fopen("my.bin", "w");// 当前目录不存在文件 会自动创建一个文件
	if (fp == NULL){
		return 1;
	}
	// fprintf/putchar 这样的接口往记事本里写我们的a, 写的时候最终会转成ASCII码值
	// int fprintf(FILE * stream, const char * format, ...);
	// 第一个参数往哪写, 第二个参数表示写谁
	fprintf(fp, "%d", a);// 显示31 30 30 30 30 => 10000

// size_t fwrite(const void * ptr, size_t size, size_t count, FILE * stream);
// 第一个参数表示要把谁写入我们的文件中, 第二个表示要写入的基本大小 第三个表示多少个基本大小
	// 最后一个参数表示往哪写 也是fopen返回值  总大小是size*count
	// 写入之前my.bin 大小为0字节 写入之后大小为4字节
	//fwrite(&a, sizeof(a), 1, fp);
	// 显示10 27 00 00  在内存里是什么样子 写在文件里就是什么样子 二进制
	fclose(fp);

	//printf("%d\n", a);//  显示在显示器的10000是5个字符 以文本形式显示 实际在内存中占4个字节

	system("pause");
	return 0;
}

// 缓冲区(在Linux中编译运行) 
// 1. 在Linux中一切皆文件
// printf往显示器文件里写数据 
// 2. C文件操作一般都有对应的缓冲区(快递店存放物品) 
// 缓冲区为了解决操作者的效率 从一个快的设备到一个慢的设备(内存 - 外设)
// 显示器是外设(慢)  (计算能力 寄存器存储能力差不多算快) 
// 3. 显示器所对应的缓冲区刷新方式默认采用 行刷新.('\n')
// 当缓冲区写满了/只要认为有一行有效 就刷新出来('\n') 并把'\n'之前的内容全部打出来
// 4. 缓冲区种类:1. 无缓冲 2. 行缓冲 3.全缓冲
// 行缓冲与全缓冲对应的缓冲区大小不同, 强制性刷新也可以
// 全缓冲效率最高 而显示器要先显示出来给人看 所以采用行缓冲(考虑人)
int main2(){
	// 有'\n'立马打出来 没'\n'等sleep完成后才被刷新出来
	//  但是一定是先执行printf, 在printf执行完毕 sleep期间 printf要打的字符串被暂时保存在一个区域里
	// 这个区域叫缓冲区
	printf("aaaaaaaaaaaaaaaaaaaaaaa\n");
	// 先把a刷新完 然后等到sleep完毕刷新出c
	printf("aaaaaaaaa\nccccccccccc");
	/* windows下的Sleep函数，首字母为大写，声明在windows.h头文件中，其参数usigned long类型，
	为毫秒数，即Sleep(1)为睡眠1毫秒。
	linux下的sleep函数，首字母为小写，声明在unistd.h头文件中，其参数为秒数，1秒 = 1000毫秒
	即sleep(1)为睡眠1秒 */
	Sleep(3000);
	printf("\n");
	system("pause");
	return 0;
}
// 显示器也是文件 所以是刷新到文件里
int main(){
	printf("aaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbb");
	fflush(stdout);// 强制刷新 没有碰到'\n'也刷新 
	Sleep(3000);
	printf("\n");
	system("pause");
	return 0;
}
